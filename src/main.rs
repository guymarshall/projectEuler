#![forbid(unsafe_code)]

use std::{collections::HashSet, ops::Rem};

/**
 * 1 - Multiples of 3 or 5
 *
 * If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
 * The sum of these multiples is 23.
 * Find the sum of all the multiples of 3 or 5 below 1000.
 */
fn multiples_of_3_or_5() {
    const LIMIT: i32 = 1000;

    let multiples_of_3: HashSet<i32> = (0..LIMIT).filter(|&number| number % 3 == 0).collect();
    let multiples_of_5: HashSet<i32> = (0..LIMIT).filter(|&number| number % 5 == 0).collect();

    let sum_of_multiples: i32 = multiples_of_3.union(&multiples_of_5).sum();
    println!("Sum: {}", sum_of_multiples)
}

/**
 * 2 - Even Fibonacci Numbers
 *
 * Each new term in the Fibonacci sequence is generated by adding the previous two terms.
 * By starting with 1 and 2, the first 10 terms will be:
 * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,...
 * By considering the terms in the Fibonacci sequence whose values do not exceed four million,
 * find the sum of the even-valued terms.
 */
fn even_fibonacci_numbers() {
    let generate_fibonacci_numbers = |maximum: i32| {
        let mut fibonacci_numbers: Vec<i32> = vec![];

        let mut first: i32 = 1;
        let mut second: i32 = 2;

        while first < maximum {
            fibonacci_numbers.push(first);
            let temp: i32 = second;
            second += first;
            first = temp;
        }

        fibonacci_numbers
    };

    let fibonacci_numbers: Vec<i32> = generate_fibonacci_numbers(4_000_000);
    let even_fibonacci_sum: i32 = fibonacci_numbers
        .iter()
        .filter(|number| number.rem(2) == 0)
        .sum();
    println!("Even fibonacci sum: {}", even_fibonacci_sum);
}

/**
 * 3 - Largest Prime Factor
 *
 * The prime factors of 13195 are 5, 7, 13 and 29.
 * What is the largest prime factor of the number 600851475143?
 */
fn largest_prime_factor() {
    let generate_factors = |input_number: i64| -> Vec<i64> {
        let ceiling_root: i64 = f64::ceil(f64::sqrt(input_number as f64)) as i64;
        (2..ceiling_root)
            .filter(|number| input_number.rem(number) == 0)
            .collect()
    };

    let is_prime = |input_number: &i64| -> bool {
        let ceiling_root: i64 = f64::ceil(f64::sqrt(*input_number as f64)) as i64;
        (2..ceiling_root).all(|number| input_number % number != 0)
    };

    const NUMBER: i64 = 600_851_475_143;
    let factors: Vec<i64> = generate_factors(NUMBER);
    let prime_factors: Vec<i64> = factors
        .iter()
        .filter(|number| is_prime(number))
        .cloned()
        .collect();
    println!(
        "Largest prime factor of {}: {}",
        NUMBER,
        prime_factors.iter().max().unwrap()
    );
}

/**
 * 4 - Largest Palindrome Product
 *
 * A palindromic number reads the same both ways. The largest palindrome made from the product of
 * two 2-digit numbers is 9009 = 91 x 99.
 * Find the largest palindrome made from the product of two 3-digit numbers.
 */
fn largest_palindrome_product() {
    let is_a_palindrome = |input_string: String| -> bool {
        input_string == input_string.chars().rev().collect::<String>()
    };

    const NUMBER_OF_DIGITS: i32 = 3;
    let maximum_number: i32 = f64::powi(10.0, NUMBER_OF_DIGITS) as i32;
    let mut largest_palindrome: i32 = 0;

    for i in 0..maximum_number {
        for j in 0..maximum_number {
            let product: i32 = i * j;
            let is_palindromic: bool = is_a_palindrome(product.to_string());

            if is_palindromic && product > largest_palindrome {
                largest_palindrome = product;
            }
        }
    }

    println!("Largest palindrome: {}", largest_palindrome);
}

/**
 * 5 - Smallest Multiple
 *
 * 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
 * What is the smallest positive number that is evenly divisible by all the numbers from 1 to 20?
 */
fn smallest_multiple() {
    let is_divisible_by =
        |number: i32, limit: i32| -> bool { (2..=limit).all(|i| number.rem(i) == 0) };

    const LIMIT: i32 = 20;
    let mut number_found: bool = false;
    let mut counter: i32 = 1;

    while !number_found {
        if is_divisible_by(counter, LIMIT) {
            number_found = true;
            println!("Smallest multiple: {}", counter);
        } else {
            counter += 1;
        }
    }
}

/**
 * 6 - Sum Square Difference
 *
 * The sum of the squares of the first ten natural numbers is,
 * 1^2 + 2^2 + ... + 10^2 = 385
 * The square of the sum of the first ten natural numbers is,
 * (1 + 2 + ... 10)^2 = 55^2 = 3025
 * Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is
 * 3025 - 385 = 2640.
 * Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
 */
fn sum_square_difference() {
    // def main():
    //     sum_of_squares = sum([number ** 2 for number in range(1, 101)])
    //     square_of_sum = sum([number for number in range(1, 101)]) ** 2
    //     difference = square_of_sum - sum_of_squares
    //     print(difference)
}

/**
 * 7 - 10001st Prime
 *
 * By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see the 6th prime is 13.
 * What is the 10001st prime number?
 */
fn find_10001st_prime() {
    // def is_prime(number: int) -> bool:
    //     ceiling_root = math.ceil(math.sqrt(number))

    //     for i in range(2, ceiling_root + 1):
    //         if number % i == 0:
    //             return False

    //     return True

    // def main():
    //     primes = []
    //     prime_count = 0
    //     number = 2

    //     while prime_count < 10000:
    //         is_prime_number = is_prime(number)

    //         if is_prime_number:
    //             primes.append(number)
    //             prime_count += 1

    //         number += 1

    //     print(primes.pop())
}

/**
 * 8 - Largest Product in a Series
 *
 * The four adjacent digits in the 1000-digit number that have the greatest product are 9 x 9 x 8 x 9 = 5832.
 * Find the thirteen adjacent digits in the 1000-digit number that have the greatest product.
 * What is the value of this product?
 */
fn largest_product_in_a_series() {
    // def main():
    //     with open('8_large_number.txt', mode='r') as file:
    //         large_number_string: str = file.read()

    //     largest_product: int = 0
    //     number_of_digits: int = 13

    //     start_index: int = 0
    //     end_index: int = (start_index + number_of_digits) - 1

    //     while end_index < len(large_number_string):
    //         product: int = int(large_number_string[start_index])

    //         temp_index = start_index + 1

    //         while temp_index <= end_index:
    //             product *= int(large_number_string[temp_index])
    //             temp_index += 1

    //         if product > largest_product:
    //             largest_product = product

    //         start_index += 1
    //         end_index += 1

    //     print(largest_product)
}

/**
 * 9 - Special Pythagorean Triplet
 *
 * A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
 * a^2 + b^2 = c^2
 * For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
 * There exists exactly one Pythagorean triplet for which a + b + c = 1000.
 * Find the product abc.
 */
fn special_pythagorean_triplet() {
    // def main():
    //     pythagorean_triplets: list = []

    //     for a in range(1, 1000):
    //         for b in range(1, 1000):
    //             for c in range(1, 1000):
    //                 is_pythagorean_triplet: bool = (a ** 2) + (b ** 2) == (c ** 2)

    //                 if is_pythagorean_triplet:
    //                     total = a + b + c

    //                     if total == 1000:
    //                         print(a * b * c)
}

/**
 * 10 - Summation of Primes
 *
 * The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
 * Find the sum of all the primes below two million.
 */
fn summation_of_primes() {
    // def is_prime(number: int) -> bool:
    //     if number == 2:
    //         return True

    //     ceiling_root: int = math.ceil(math.sqrt(number))

    //     for i in range(2, ceiling_root + 1):
    //         if number % i == 0:
    //             return False

    //     return True

    // def main():
    //     start: int = 2
    //     finish: int = 2_000_000

    //     primes_below_limit: list = [number for number in range(start, finish) if is_prime(number)]

    //     print(sum(primes_below_limit))
}

fn main() {
    multiples_of_3_or_5();
    even_fibonacci_numbers();
    largest_prime_factor();
    largest_palindrome_product();
    smallest_multiple();
    sum_square_difference();
    find_10001st_prime(); // prefixed with find_ to stop Rust complaining
    largest_product_in_a_series();
    special_pythagorean_triplet();
    summation_of_primes();
}
